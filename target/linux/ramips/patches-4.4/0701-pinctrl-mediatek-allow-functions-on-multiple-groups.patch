--- a/arch/mips/include/asm/mach-ralink/pinmux.h
+++ b/arch/mips/include/asm/mach-ralink/pinmux.h
@@ -33,6 +33,7 @@ struct rt2880_pmx_func {
 	int *pins;
 
 	int *groups;
+	const char **group_names;
 	int group_count;
 
 	int enabled;
--- a/drivers/pinctrl/pinctrl-rt2880.c
+++ b/drivers/pinctrl/pinctrl-rt2880.c
@@ -187,10 +187,8 @@ static int rt2880_pmx_group_get_groups(s
 {
 	struct rt2880_priv *p = pinctrl_dev_get_drvdata(pctrldev);
 
-	if (p->func[func]->group_count == 1)
-		*groups = &p->group_names[p->func[func]->groups[0]];
-	else
-		*groups = p->group_names;
+	if (p->func[func]->group_count != 0)
+		*groups = p->func[func]->group_names;
 
 	*num_groups = p->func[func]->group_count;
 
@@ -204,7 +202,7 @@ static int rt2880_pmx_group_enable(struc
 	struct rt2880_priv *p = pinctrl_dev_get_drvdata(pctrldev);
         u32 mode = 0;
 	u32 reg = SYSC_REG_GPIO_MODE;
-	int i;
+	int i, j;
 	int shift;
 
 	/* dont allow double use */
@@ -232,8 +230,13 @@ static int rt2880_pmx_group_enable(struc
 	if (func == 0) {
 		mode |= p->groups[group].gpio << shift;
 	} else {
-		for (i = 0; i < p->func[func]->pin_count; i++)
-			p->gpio[p->func[func]->pins[i]] = 0;
+		for (j = 0; j < p->groups[group].func_count; j++){
+			if (strcmp(p->groups[group].func[j].name, p->func[func]->name) == 0){
+				for (i = 0; i < p->groups[group].func[j].pin_count; i++){
+					p->gpio[p->groups[group].func[j].pins[i]] = 0;
+				}
+			}
+		}
 		mode |= p->func[func]->value << shift;
 	}
 	rt_sysc_w32(mode, reg);
@@ -317,12 +320,34 @@ static int rt2880_pinmux_index(struct rt
 	for (i = 0; i < p->group_count; i++) {
 		for (j = 0; j < p->groups[i].func_count; j++) {
 			f[c] = &p->groups[i].func[j];
-			f[c]->groups = devm_kzalloc(p->dev, sizeof(int), GFP_KERNEL);
+			f[c]->groups = devm_kzalloc(p->dev, sizeof(int) *
+					p->group_count, GFP_KERNEL);
+			if (!f[c]->groups)
+				return -1;
+			f[c]->group_names = devm_kzalloc(p->dev, sizeof(char *)
+					* p->group_count, GFP_KERNEL);
+			if (!f[c]->group_names)
+				return -1;
 			f[c]->groups[0] = i;
 			f[c]->group_count = 1;
 			c++;
 		}
 	}
+	f[0]->group_names = p->group_names;
+	for (c = 1; c < p->func_count; c++) {
+		f[c]->group_count = 0;
+		for (i = 0; i < p->group_count; i++) {
+			for (j = 0; j < p->groups[i].func_count; j++) {
+				if (strcmp(f[c]->name,p->groups[i].func[j].name)
+						== 0) {
+					f[c]->groups[f[c]->group_count] = i;
+					f[c]->group_names[f[c]->group_count] =
+						p->groups[i].name;
+					f[c]->group_count++;
+				}
+			}
+		}
+	}
 	return 0;
 }
 
