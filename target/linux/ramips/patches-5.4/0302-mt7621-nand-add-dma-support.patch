--- a/drivers/mtd/nand/raw/mt7621_nand.c
+++ b/drivers/mtd/nand/raw/mt7621_nand.c
@@ -19,6 +19,7 @@
 #include <linux/mtd/rawnand.h>
 #include <linux/mtd/partitions.h>
 #include <linux/platform_device.h>
+#include <linux/reset.h>
 #include <asm/addrspace.h>
 
 /* NFI core registers */
@@ -117,6 +118,13 @@
 #define   CSEL_S			0
 #define   CSEL_M			GENMASK(1, 0)
 
+#define NFI_IOCON			0x094
+#define   IOCON_BRSTN_S			4
+#define   IOCON_BRSTN_M			GENMASK(7, 4)
+#define   IOCON_L2NW			BIT(2)
+#define   IOCON_L2NR			BIT(1)
+#define   IOCON_NLDPD			BIT(0)
+
 #define NFI_FDM0L			0x0a0
 #define NFI_FDML(n)			(0x0a0 + ((n) << 3))
 
@@ -259,25 +267,6 @@ static inline void ecc_write32(struct mt
 	return writel(val, nfc->ecc_regs + reg);
 }
 
-static inline u8 *oob_fdm_ptr(struct nand_chip *nand, int sect)
-{
-	return nand->oob_poi + sect * NFI_FDM_SIZE;
-}
-
-static inline u8 *oob_ecc_ptr(struct mt7621_nfc *nfc, int sect)
-{
-	struct nand_chip *nand = &nfc->nand;
-
-	return nand->oob_poi + nand->ecc.steps * NFI_FDM_SIZE +
-		sect * (nfc->spare_per_sector - NFI_FDM_SIZE);
-}
-
-static inline u8 *page_data_ptr(struct nand_chip *nand, const u8 *buf,
-				int sect)
-{
-	return (u8 *)buf + sect * nand->ecc.size;
-}
-
 static int mt7621_ecc_wait_idle(struct mt7621_nfc *nfc, u32 reg)
 {
 	struct device *dev = nfc->dev;
@@ -416,6 +405,8 @@ static inline void mt7621_nfc_hw_init(st
 {
 	u32 acccon;
 
+	device_reset(nfc->dev);
+
 	/*
 	 * CNRNB: nand ready/busy register
 	 * -------------------------------
@@ -432,6 +423,10 @@ static inline void mt7621_nfc_hw_init(st
 			   ACCCON_RLT_DEF);
 
 	nfi_write32(nfc, NFI_ACCCON, acccon);
+
+	/* data bus bull down when no use */
+	nfi_write16(nfc, NFI_IOCON, (4 << IOCON_BRSTN_S) | IOCON_L2NW |
+		    IOCON_L2NR | IOCON_NLDPD);
 }
 
 static int mt7621_nfc_send_command(struct mt7621_nfc *nfc, u8 command)
@@ -789,6 +784,7 @@ static int mt7621_nfc_calc_ecc_strength(
 	}
 
 	nand->ecc.strength = mt7621_ecc_strength[i];
+	nand->ecc.prepad = NFI_FDM_SIZE;
 	nand->ecc.bytes =
 		DIV_ROUND_UP(nand->ecc.strength * ECC_PARITY_BITS, 8);
 
@@ -820,6 +816,7 @@ static int mt7621_nfc_set_spare_per_sect
 	}
 
 	nfc->spare_per_sector = mt7621_nfi_spare_size[i];
+	nand->ecc.postpad = mt7621_nfi_spare_size[i] - size;
 
 	return i;
 }
@@ -927,12 +924,23 @@ static int mt7621_nfc_ooblayout_free(str
 				     struct mtd_oob_region *oob_region)
 {
 	struct nand_chip *nand = mtd_to_nand(mtd);
+	int chunk = nand->ecc.prepad + nand->ecc.bytes + nand->ecc.postpad;
 
-	if (section >= nand->ecc.steps)
+	if (section > nand->ecc.steps)
 		return -ERANGE;
 
-	oob_region->length = NFI_FDM_SIZE - 1;
-	oob_region->offset = section * NFI_FDM_SIZE + 1;
+	oob_region->length = nand->ecc.prepad;
+	oob_region->offset = section * chunk;
+
+	if (section == 0) {
+		oob_region->length -= 1;
+		oob_region->offset = 1;
+	} else if (section == nand->ecc.steps) {
+		chunk = mtd->oobsize - (nand->ecc.steps * chunk);
+		if (!chunk)
+			return -ERANGE;
+		oob_region->length = chunk;
+	}
 
 	return 0;
 }
@@ -941,12 +949,13 @@ static int mt7621_nfc_ooblayout_ecc(stru
 				    struct mtd_oob_region *oob_region)
 {
 	struct nand_chip *nand = mtd_to_nand(mtd);
+	int chunk = nand->ecc.prepad + nand->ecc.bytes + nand->ecc.postpad;
 
-	if (section)
+	if (section >= nand->ecc.steps)
 		return -ERANGE;
 
-	oob_region->offset = NFI_FDM_SIZE * nand->ecc.steps;
-	oob_region->length = mtd->oobsize - oob_region->offset;
+	oob_region->offset = section * chunk + nand->ecc.prepad;
+	oob_region->length = nand->ecc.bytes + nand->ecc.postpad;
 
 	return 0;
 }
@@ -956,45 +965,76 @@ static const struct mtd_ooblayout_ops mt
 	.ecc = mt7621_nfc_ooblayout_ecc,
 };
 
-static void mt7621_nfc_write_fdm(struct mt7621_nfc *nfc)
+static void mt7621_nfc_write_fdm(struct mt7621_nfc *nfc, int oob_required)
 {
 	struct nand_chip *nand = &nfc->nand;
-	u32 vall, valm;
-	u8 *oobptr;
-	int i, j;
+	u8 *oobptr = nand->oob_poi;
+	uint32_t fdm[2];
+	int i;
 
+	fdm[0] = fdm[1] = 0xffffffff;
 	for (i = 0; i < nand->ecc.steps; i++) {
-		vall = 0;
-		valm = 0;
-		oobptr = oob_fdm_ptr(nand, i);
-
-		for (j = 0; j < 4; j++)
-			vall |= (u32)oobptr[j] << (j * 8);
-
-		for (j = 0; j < 4; j++)
-			valm |= (u32)oobptr[j + 4] << ((j - 4) * 8);
-
-		nfi_write32(nfc, NFI_FDML(i), vall);
-		nfi_write32(nfc, NFI_FDMM(i), valm);
+		if (oob_required) {
+			memcpy(&fdm, oobptr, sizeof(fdm));
+			oobptr += nfc->spare_per_sector;
+		}
+		nfi_write32(nfc, NFI_FDML(i), fdm[0]);
+		nfi_write32(nfc, NFI_FDMM(i), fdm[1]);
 	}
 }
 
 static void mt7621_nfc_read_sector_fdm(struct mt7621_nfc *nfc, u32 sect)
 {
 	struct nand_chip *nand = &nfc->nand;
-	u32 vall, valm;
+	uint32_t fdm[2];
 	u8 *oobptr;
-	int i;
 
-	vall = nfi_read32(nfc, NFI_FDML(sect));
-	valm = nfi_read32(nfc, NFI_FDMM(sect));
-	oobptr = oob_fdm_ptr(nand, sect);
+	fdm[0] = nfi_read32(nfc, NFI_FDML(sect));
+	fdm[1] = nfi_read32(nfc, NFI_FDMM(sect));
+	oobptr = nand->oob_poi + (sect * nfc->spare_per_sector);
+	memcpy(oobptr, fdm, sizeof(fdm));
+}
+
+static int mt7621_read_parity_oob(struct mtd_info *mtd, struct nand_chip *nand,
+			   int page)
+{
+	struct mt7621_nfc *nfc = nand_get_controller_data(nand);
+	int chunk = nand->ecc.bytes + nand->ecc.postpad;
+	int eccsize = nand->ecc.size + nand->ecc.prepad;
+	int i, sndrnd = 0, pos, ret;
+	u8 *oobptr = nand->oob_poi + nand->ecc.prepad;
+
+	ret = nand_read_page_op(nand, page, eccsize, NULL, 0);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < nand->ecc.steps; i++, oobptr += nfc->spare_per_sector) {
+		if (sndrnd) {
+			pos = eccsize + i * (eccsize + chunk);
+			if (mtd->writesize > 512)
+				ret = nand_change_read_column_op(nand, pos,
+								 NULL, 0,
+								 false);
+			else
+				ret = nand_read_page_op(nand, page, pos, NULL,
+							0);
+			if (ret)
+				return ret;
+		} else
+			sndrnd = 1;
+		ret = nand_read_data_op(nand, oobptr, chunk, false);
+		if (ret)
+			return ret;
+	}
 
-	for (i = 0; i < 4; i++)
-		oobptr[i] = (vall >> (i * 8)) & 0xff;
+	chunk = mtd->oobsize - (nand->ecc.steps * nfc->spare_per_sector);
+	if (chunk) {
+		oobptr = nand->oob_poi + (nand->ecc.steps *
+					  nfc->spare_per_sector);
+		ret = nand_read_data_op(nand, oobptr, chunk, false);
+	}
 
-	for (i = 0; i < 4; i++)
-		oobptr[i + 4] = (valm >> (i * 8)) & 0xff;
+	return 0;
 }
 
 static int mt7621_nfc_read_page_hwecc(struct nand_chip *nand, uint8_t *buf,
@@ -1004,6 +1044,7 @@ static int mt7621_nfc_read_page_hwecc(st
 	struct mtd_info *mtd = nand_to_mtd(nand);
 	int bitflips = 0;
 	int rc, i;
+	u8 *oobptr = nand->oob_poi;
 
 	nand_read_page_op(nand, page, 0, NULL, 0);
 
@@ -1015,25 +1056,25 @@ static int mt7621_nfc_read_page_hwecc(st
 	nfi_write16(nfc, NFI_CON,
 		    CON_NFI_BRD | (nand->ecc.steps << CON_NFI_SEC_S));
 
-	for (i = 0; i < nand->ecc.steps; i++) {
+	for (i = 0; i < nand->ecc.steps; i++,
+	     buf ? buf += nand->ecc.size : NULL,
+	     oobptr += nfc->spare_per_sector) {
 		if (buf)
-			mt7621_nfc_read_data(nfc, page_data_ptr(nand, buf, i),
-					     nand->ecc.size);
+			mt7621_nfc_read_data(nfc, buf, nand->ecc.size);
 		else
 			mt7621_nfc_read_data_discard(nfc, nand->ecc.size);
 
 		rc = mt7621_ecc_decoder_wait_done(nfc, i);
 
-		mt7621_nfc_read_sector_fdm(nfc, i);
+		if (oob_required)
+			mt7621_nfc_read_sector_fdm(nfc, i);
 
 		if (rc < 0) {
 			bitflips = -EIO;
 			continue;
 		}
 
-		rc = mt7621_ecc_correct_check(nfc,
-			buf ? page_data_ptr(nand, buf, i) : NULL,
-			oob_fdm_ptr(nand, i), i);
+		rc = mt7621_ecc_correct_check(nfc, buf, oobptr, i);
 
 		if (rc < 0) {
 			dev_warn(nfc->dev,
@@ -1051,6 +1092,9 @@ static int mt7621_nfc_read_page_hwecc(st
 
 	nfi_write16(nfc, NFI_CON, 0);
 
+	if (oob_required)
+		mt7621_read_parity_oob(mtd, nand, page);
+
 	return bitflips;
 }
 
@@ -1058,6 +1102,7 @@ static int mt7621_nfc_read_page_raw(stru
 				    int oob_required, int page)
 {
 	struct mt7621_nfc *nfc = nand_get_controller_data(nand);
+	u8 *oobptr = nand->oob_poi;
 	int i;
 
 	nand_read_page_op(nand, page, 0, NULL, 0);
@@ -1068,20 +1113,17 @@ static int mt7621_nfc_read_page_raw(stru
 	nfi_write16(nfc, NFI_CON,
 		    CON_NFI_BRD | (nand->ecc.steps << CON_NFI_SEC_S));
 
-	for (i = 0; i < nand->ecc.steps; i++) {
+	for (i = 0; i < nand->ecc.steps; i++,
+	     buf ? buf += nand->ecc.size : NULL,
+	     oobptr += nfc->spare_per_sector) {
 		/* Read data */
 		if (buf)
-			mt7621_nfc_read_data(nfc, page_data_ptr(nand, buf, i),
-					     nand->ecc.size);
+			mt7621_nfc_read_data(nfc, buf, nand->ecc.size);
 		else
 			mt7621_nfc_read_data_discard(nfc, nand->ecc.size);
 
-		/* Read FDM */
-		mt7621_nfc_read_data(nfc, oob_fdm_ptr(nand, i), NFI_FDM_SIZE);
-
-		/* Read ECC parity data */
-		mt7621_nfc_read_data(nfc, oob_ecc_ptr(nfc, i),
-				     nfc->spare_per_sector - NFI_FDM_SIZE);
+		/* Read FDM and ECC parity data */
+		mt7621_nfc_read_data(nfc, oobptr, nfc->spare_per_sector);
 	}
 
 	nfi_write16(nfc, NFI_CON, 0);
@@ -1102,19 +1144,18 @@ static int mt7621_nfc_read_oob_raw(struc
 static int mt7621_nfc_check_empty_page(struct nand_chip *nand, const u8 *buf)
 {
 	struct mtd_info *mtd = nand_to_mtd(nand);
-	uint32_t i, j;
-	u8 *oobptr;
+	unsigned long *datum;
+	int i;
 
-	for (i = 0; i < mtd->writesize; i++)
-		if (buf[i] != 0xff)
+	datum = (unsigned long *)buf;
+	for (i = 0; i < mtd->writesize; i += sizeof(*datum))
+		if (*datum++ + 1)
 			return 0;
 
-	for (i = 0; i < nand->ecc.steps; i++) {
-		oobptr = oob_fdm_ptr(nand, i);
-		for (j = 0; j < NFI_FDM_SIZE; j++)
-			if (oobptr[j] != 0xff)
-				return 0;
-	}
+	datum = (unsigned long *)nand->oob_poi;
+	for (i = 0; i < mtd->oobsize; i += sizeof(*datum))
+		if (*datum++ + 1)
+			return 0;
 
 	return 1;
 }
@@ -1146,7 +1187,7 @@ static int mt7621_nfc_write_page_hwecc(s
 
 	mt7621_ecc_encoder_op(nfc, true);
 
-	mt7621_nfc_write_fdm(nfc);
+	mt7621_nfc_write_fdm(nfc, oob_required);
 
 	nfi_write16(nfc, NFI_CON,
 		    CON_NFI_BWR | (nand->ecc.steps << CON_NFI_SEC_S));
@@ -1170,6 +1211,7 @@ static int mt7621_nfc_write_page_raw(str
 				     int page)
 {
 	struct mt7621_nfc *nfc = nand_get_controller_data(nand);
+	u8 *oobptr = nand->oob_poi;
 	int i;
 
 	nand_prog_page_begin_op(nand, page, 0, NULL, 0);
@@ -1179,21 +1221,17 @@ static int mt7621_nfc_write_page_raw(str
 	nfi_write16(nfc, NFI_CON,
 		    CON_NFI_BWR | (nand->ecc.steps << CON_NFI_SEC_S));
 
-	for (i = 0; i < nand->ecc.steps; i++) {
+	for (i = 0; i < nand->ecc.steps; i++,
+	     buf ? buf += nand->ecc.size : NULL,
+	     oobptr += nfc->spare_per_sector) {
 		/* Write data */
 		if (buf)
-			mt7621_nfc_write_data(nfc, page_data_ptr(nand, buf, i),
-					      nand->ecc.size);
+			mt7621_nfc_write_data(nfc, buf, nand->ecc.size);
 		else
 			mt7621_nfc_write_data_empty(nfc, nand->ecc.size);
 
-		/* Write FDM */
-		mt7621_nfc_write_data(nfc, oob_fdm_ptr(nand, i),
-				      NFI_FDM_SIZE);
-
-		/* Write dummy ECC parity data */
-		mt7621_nfc_write_data_empty(nfc, nfc->spare_per_sector -
-					    NFI_FDM_SIZE);
+		/* Write FDM and ECC parity data */
+		mt7621_nfc_write_data(nfc, oobptr, nfc->spare_per_sector);
 	}
 
 	mt7621_nfc_wait_write_completion(nfc, nand);
@@ -1299,6 +1337,16 @@ static int mt7621_nfc_probe(struct platf
 			return ret;
 		}
 	}
+#if 1
+	/* enable clock */
+	{
+#define RALINK_SYSCTL_BASE      0xBE000000
+		u32 reg = (*(volatile u32 *)(RALINK_SYSCTL_BASE + 0x30));
+		reg |= BIT(15);
+		reg &= ~(BIT(30) | BIT(18));
+		(*(volatile u32 *)(RALINK_SYSCTL_BASE + 0x30)) = reg;
+	}
+#endif
 
 	platform_set_drvdata(pdev, nfc);
 
